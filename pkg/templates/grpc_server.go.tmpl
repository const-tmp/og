package grpc

import (
    "context"
    "core/internal/ledger/endpoints"
    "core/internal/ledger/proto"
    "github.com/go-kit/kit/transport/grpc"
)

type grpcServer struct {
    proto.Unimplemented{{ .ServiceName }}Server
	{{ range .Endpoints }}
	{{ .Name | unexported }} grpc.Handler
	{{ end }}
}

{{ range .Endpoints }}
func (s *grpcServer) {{ .Name }}(ctx context.Context, req *proto.{{ .Name }}Request) (*proto.{{ .Name }}Response, error) {
    _, rep, err := s.{{ .Name | unexported }}.ServeGRPC(ctx, req)
    if err != nil {
        return nil, err
    }
    return rep.(*proto.{{ .Name }}Response), nil
}
{{ end }}

// decodeGRPCSumRequest is a transport/grpc.DecodeRequestFunc that converts a
// gRPC sum request to a user-domain sum request. Primarily useful in a server.
func decodeGRPCSumRequest(_ context.Context, grpcReq interface{}) (interface{}, error) {
    req := grpcReq.(*pb.SumRequest)
    return addendpoint.SumRequest{A: int(req.A), B: int(req.B)}, nil
}

// decodeGRPCSumResponse is a transport/grpc.DecodeResponseFunc that converts a
// gRPC sum reply to a user-domain sum response. Primarily useful in a client.
func decodeGRPCSumResponse(_ context.Context, grpcReply interface{}) (interface{}, error) {
    reply := grpcReply.(*pb.SumReply)
    return addendpoint.SumResponse{V: int(reply.V), Err: str2err(reply.Err)}, nil
}

func DecodeDepositRequest(request *proto.DepositRequest) endpoints.DepositRequest {
    return endpoints.NewDepositRequest()
}

func EncodeDepositResponse(response *endpoints.DepositResponse) *proto.DepositResponse {
    return endpoints.NewDepositResponse()
}

func (s *grpcServer) Deposit(ctx context.Context, request *proto.DepositRequest) (*proto.DepositResponse, error) {
    _, res, err := s.deposit.ServeGRPC(ctx, endpoints.NewDepositRequest(request.AccountId, request.Currency, request.Amount, request.TxType))
    return EncodeDepositResponse(endpoints.NewDepositResponse(res.(types.TransactionType), err)), nil
}

func (s *grpcServer) Withdraw(ctx context.Context, request *proto.WithdrawRequest) (*proto.WithdrawResponse, error) {
    //TODO implement me
    panic("implement me")
}

func (s *grpcServer) CancelTransaction(ctx context.Context, request *proto.CancelTransactionRequest) (*proto.CancelTransactionResponse, error) {
    //TODO implement me
    panic("implement me")
}

func (s *grpcServer) GetBalance(ctx context.Context, request *proto.GetBalanceRequest) (*proto.GetBalanceResponse, error) {
    //TODO implement me
    panic("implement me")
}

func (s *grpcServer) mustEmbedUnimplementedServiceServer() {
    //TODO implement me
    panic("implement me")
}

// NewGRPCServer makes a set of endpoints available as a gRPC AddServer.
func NewGRPCServer(endpoints endpoints.EndpointSet) proto.UnsafeServiceServer {
    options := []grpc.ServerOption{
        //grpc.ServerErrorHandler(transport.NewLogErrorHandler(logger)),
    }

    return &grpcServer{
        deposit: grpc.NewServer(
            endpoints.DepositEndpoint,
            decodeGRPCSumRequest,
            encodeGRPCSumResponse,
        ),
        withdraw: grpc.NewServer(
            endpoints.WithdrawEndpoint,
            decodeGRPCConcatRequest,
            encodeGRPCConcatResponse,
        ),
        cancelTransaction: grpc.NewServer(
            endpoints.CancelTransactionEndpoint,
            decodeGRPCConcatRequest,
            encodeGRPCConcatResponse,
        ),
        getBalance: grpc.NewServer(
            endpoints.GetBalanceEndpoint,
            decodeGRPCSumRequest,
            encodeGRPCSumResponse,
        ),
    }
}

func (s *grpcServer) Sum(ctx context.Context, req *pb.SumRequest) (*pb.SumReply, error) {
    _, rep, err := s.sum.ServeGRPC(ctx, req)
    if err != nil {
        return nil, err
    }
    return rep.(*pb.SumReply), nil
}

func (s *grpcServer) Concat(ctx context.Context, req *pb.ConcatRequest) (*pb.ConcatReply, error) {
    _, rep, err := s.concat.ServeGRPC(ctx, req)
    if err != nil {
        return nil, err
    }
    return rep.(*pb.ConcatReply), nil
}
